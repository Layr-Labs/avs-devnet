# EigenLayer AVS Devnet

*AvsDevnet* is a CLI tool and library to start highly customizable local devnets.
The CLI tool is used in place of bash scripts for end-to-end testing and local development.
The library, on the other hand, is commonly used in place of mocks for automated testing of specific situations.

> [!WARNING]
> Currently, only the [Kurtosis package](./kurtosis_package/) and [CLI](./cli/) are available.
> Future versions may include the testing library.

## Dependencies

Since the Devnet is implemented as a Kurtosis package, we require Kurtosis to be installed.
For how to install it, you can check [here](https://docs.kurtosis.com/install/).
As part of that, you'll also need to install Docker.

For local development, we require the `go` toolchain to be installed.

## Installation

To build and install the CLI locally, run:

```sh
make deps      # installs dependencies
make install   # installs the project

# this command should be run once per shell
source env.sh  # set env-vars
```

## How to Use

### Creating a devnet config

This will create a new devnet config.
By default it's stored as `devnet.yaml`, but another name can be passed as parameter.

```sh
devnet init
```

The default configuration deploys EigenLayer with a single strategy and operator.
It also starts up a [blockscout explorer](https://github.com/blockscout/blockscout).

### Starting the devnet

This will start a devnet according to the configuration inside `devnet.yaml`.
Another file name can be specified as the first parameter.

```sh
devnet start
```

Note that only one devnet per file name can be running at the same time.
Trying to start another one (or the same one more than once) will fail.

### Stopping the devnet

This will stop the devnet according to the configuration inside `devnet.yaml`.
Another file name can be specified as the first parameter.

```sh
devnet stop
```

### Fetching the address of a contract

This will output the address of the deployed contract named `delegation`, from the artifact `eigenlayer_addresses`.
In the default configuration, this corresponds to the address of EigenLayer's `DelegationManager`.

```sh
$ devnet get-address eigenlayer_addresses:delegation
0x9f9F5Fd89ad648f2C000C954d8d9C87743243eC5
```

This works by parsing the JSON artifacts generated by the deployment scripts.
The command expects there to be a single file with a field called "addresses" under which addresses are listed.

More examples:

```sh
# print all addresses in eigenlayer_addresses artifact
$ devnet get-address eigenlayer_addresses:
{
  "addresses": {
    # ...
    "delegation": "0x9f9F5Fd89ad648f2C000C954d8d9C87743243eC5",
    # ...
    "strategies": {
      "MockETH": "0x2b45cD38B213Bbd3A1A848bf2467927c976877Cb"
    },
    # ...
  },
  # ...
}
# print the address under strategies -> MockETH
$ devnet get-address eigenlayer_addresses:strategies.MockETH
0x2b45cD38B213Bbd3A1A848bf2467927c976877Cb
# because we also search nested entries, the last one can be shortened to
$ devnet get-address eigenlayer_addresses:MockETH
0x2b45cD38B213Bbd3A1A848bf2467927c976877Cb
# by adding a . at the start, we disable the search function
$ devnet get-address eigenlayer_addresses:.MockETH  # this fails
Contract not found: eigenlayer_addresses:.MockETH
```

### Local development

Some fields in the config can be used to ease deployment of local projects.

The `repo` field in `deployments` accepts local paths.
This can be used when deployments should be done from locally available versions.

```yaml
deployments:
  - name: some-deployment
    repo: "foo/bar/baz"
```

The `build_context` field in `services`, if specified, allows the Devnet to automatically build docker images via `docker build`.
Images are built in the specified context, and tagged with the name specified in the `image` field.
If the build file is named something other than `Dockerfile`, or isn't located in the context, you can use `build_file` to specify the path.

```yaml
services:
  - name: my-service
    image: some-local-image-name
    build_context: path/to/context
    build_file: path/to/context/Dockerfile
```

### More Help

You can find the options for each command by appending `--help`:

```sh
$ devnet --help
NAME:
   devnet - start an AVS devnet

USAGE:
   devnet [global options] command [command options]

VERSION:
   development

COMMANDS:
   init         Initialize a devnet configuration file
   start        Start devnet from configuration file
   stop         Stop devnet from configuration file
   get-address  Get a devnet contract or EOA address
   help, h      Shows a list of commands or help for one command

GLOBAL OPTIONS:
   --help, -h     show help
   --version, -v  print the version
```

## Configuration

An example (non-functional) configuration is:

```yaml
# Lists the contracts to deploy
deployments:
    # The name of the contract group
  - name: deployment-name
    # The repo to fetch the contracts from
    repo: "https://github.com/some-org/some-repo.git"
    # This can also be a local path (absolute or relative)
    # repo: ./foo/bar
    # The commit/branch/tag to use
    ref: "d05341ef33e5853fd3ecef831ae4dcfbf29c5299"
    # The path to the foundry project inside the repo
    contracts_path: "contracts/"
    # The path to the deployer script (may include the contract name after ':')
    script: script/deploy/devnet/M2_Deploy_From_Scratch.s.sol:Deployer_M2
    # Extra args passed on to `forge script`
    extra_args: --sig 'run(string memory configFile)' -- deploy_from_scratch.config.json
    # Environment variables to set for deployment
    env:
      # Key: env variable name
      # Value: env variable's value
      key: value
      # Variables starting with `$` are magic variables and change to the real value at runtime
      PRIVATE_KEY: "$deployer_private_key"
    # Input files to embed into the repo
    input:
      # Key: destination to insert the files in
      # Value: name of the artifact containing the files
      script/configs/devnet/: eigenlayer_deployment_input
      # Multiple artifacts can be specified and all artifact files will be stored
      # in the directory
      some/other/dir/: 
        - file_a
        - file_b
    # Output files to store after execution
    output:
      # Key: name of the new artifact
      # Value: path to the file to store in the artifact
      eigenlayer_addresses: "script/output/devnet/M2_from_scratch_deployment_data.json"
      # You can also specify a new name for the file before storing it
      eigenlayer_addresses_renamed:
        # Same as before
        path: "script/output/devnet/M2_from_scratch_deployment_data.json"
        # The new name to give to the file
        rename: "eigenlayer_deployment_output.json"

    # Available types: eigenlayer
    # This autofills some of the other options, and allows access
    # to additional arguments
  - type: eigenlayer
    # Same as before
    ref: v0.4.2-mainnet-pepe
    # The strategies to deploy, all of them backed by the same mocked token
    strategies:
      # The strategy name
      - MockETH
    # The operators to register in EigenLayer
    operators:
        # The name of the operator
      - name: operator1
        # The keys
        keys: ecdsa_keys
        # The strategies to deposit shares in
        strategies:
          # strategy_name: number_of_tokens
          MockETH: 100000000000000000

# Lists the services to start after the contracts are deployed
services:
    # Name for the service
  - name: "aggregator"
    # The docker image to use
    image: "ghcr.io/layr-labs/incredible-squaring/aggregator/cmd/main.go:latest"
    # Local images are built automatically when specifying `build_context`
    # Specifies the context for the image's dockerfile
    build_context: path/to/context
    # Optional. Used to override the default of "build_context/Dockerfile".
    build_file: path/to/context/Dockerfile
    # The ports to expose on the container
    ports:
      # The key is a name for the port
      port_name:
        # Port number
        number: 8090
        # Port transport protocol: TCP, UDP
        transport_protocol: "TCP"
        # Application protocol: HTTP, etc.
        application_protocol: "http"
        # Timeout before failing deployment. `null` can be used to disable this.
        # Default: 15s
        wait: "10s"
    # Input files to embed into the repo
    # Same as in `deployments`
    input:
      key: value
    # Used to specify environment variables to pass to the image
    env:
      # Key: env variable name
      # Value: env variable's value
      key: value
      # Values starting with `$` can be used to retrieve context information
      # This example expands to the `ecdsa_keys` keystore's password
      ECDSA_KEY_PASSWORD: $keys.ecdsa_keys.password
    # Command to use when running the docker image
    cmd: ["some", "option", "here"]

# Lists the keys to be generated at startup
keys:
    # Name for the keys
  - name: "ecdsa_keys"
    # Type of keys: bls, ecdsa
    type: "ecdsa"
    # Key details will be dynamically generated unless specified
    # Address of the precomputed key
    address: "0xdeadbeef"
    # Private key of the precomputed key
    private_key: "0xdeadbeef"

# Lists artifacts to be generated at startup
artifacts:
  # Artifact name
  eigenlayer_deployment_input:
    # Data from other artifacts to use in the generation
    additional_data:
      # Artifact name to fetch data from
      artifact_name:
        # Key: name of the variable to populate
        # Value: JSONPath to the data
        # NOTE: this assumes that the data inside the artifact is a single JSON file
        some_variable: ".field1.foo[0]"

    # List of files to store inside the artifact
    files:
      # Key: file name
      # Value: a string to be the file's contents.
      # The string is assumed to be a Go template
      # (see https://pkg.go.dev/text/template for more information).
      # There are also some dynamically populated fields like 'deployer_address'
      someconfig.config.json: |
        {
          "a": 5,
          "someVariable": {{.some_variable}},
          "deployerAddress": {{.deployer_address}}
        }

# Args to pass on to ethereum-package.
# See https://github.com/ethpandaops/ethereum-package for more information
ethereum_package:
  participants:
    - el_type: erigon
  additional_services:
    - blockscout
```

## Kurtosis package

> [!WARNING]
> Some features won't be available when starting the devnet via Kurtosis CLI.
> This is because the CLI pre-processes some parts of the args-file before invoking Kurtosis.

### How to run

> [!WARNING]
> Since `Layr-Labs/avs-devnet` is a private repository, you'll need to login with `kurtosis github login` to access it.

[After Kurtosis is installed](#dependencies), you can run [the default config](kurtosis_package/devnet_params.yaml). This spins up a local Ethereum devnet with a single node and all EigenLayer core contracts deployed. It also includes the [blockscout](https://github.com/blockscout/blockscout) explorer.

```sh
kurtosis run github.com/Layr-Labs/avs-devnet --enclave my_devnet --args-file github.com/kurtosis_package/devnet_params.yaml
```

What follows is a brief tutorial on Kurtosis CLI.
For more information, you can check [the documentation](https://docs.kurtosis.com/).

#### Run a custom configuration

To run a different configuration, you can write your own config file and pass it to the package like so:

```sh
kurtosis run github.com/Layr-Labs/avs-devnet --enclave my_devnet --args-file devnet_params.yaml
```

For example configurations, check [`examples`](examples/). For more information on the config file format, check [Configuration](#configuration).

#### Stopping and deleting the devnet

In the past commands, we specified the name of the enclave with the `--enclave` flag.
If no name was specified, Kurtosis will generate a random one.
You can check existing enclaves with:

```sh
kurtosis enclave ls
```

Since we named our enclave `my_devnet`, you can stop it with:

```sh
kurtosis enclave stop my_devnet
```

For destroying a stopped enclave, you can use:

```sh
kurtosis enclave rm my_devnet
```

#### Download file artifacts

The devnet can generate various file artifacts (e.g. with contract addresses).
You can see a list by running:

```sh
kurtosis enclave inspect my_devnet
```

To download this data from the Kurtosis engine, use:

```sh
kurtosis files download my_devnet <artifact name>
```

This produces a folder named like the artifact containing its files.

## Contributing

We have a Makefile for some of the usual tasks.
Run `make help` for more info.
